# -*- coding: utf-8 -*-
"""PavangandhiQ1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L04dANfdgCqRJLRDBC558bPf-DbHPKRp
"""

import pandas as pd
import sys
import csv
from datetime import datetime
from dateutil import relativedelta

#Creating custom exception to throw error if age is not in range
class AgeNotInRangeError(Exception):
    def __init__(self, age, message="Age is not in (25, 65) range"):
        self.age = age
        self.message = message
        super().__init__(self.message)
  
class Employee():
  #Constructor class to initialize all the required parameters
  def __init__(self, name, gender, date_of_birth, date_of_joining, hobbies):
    self.name = name
    self.gender = gender
    
    while self.check_date_format(date_of_birth) != True:
      date_of_birth = input("Input Date of Birth in DD-MM-YYYY format please!")
    
    self.calculate_age(date_of_birth)
    try:      
      if not 24 < self.age < 66:
        raise AgeNotInRangeError(self.age)
    except AgeNotInRangeError:
      print("Age Invalid Error encountered, Object cannot be created.")
      sys.exit("Exiting Code.")
    else:
      self.date_of_birth = date_of_birth

    while self.check_date_format(date_of_joining) != True:
      date_of_joining = input("Input Date of Joining in DD-MM-YYYY format please!")
    self.date_of_joining = date_of_joining

    self.hobbies = hobbies
    self.salary = 10000
    self.level = 1

    join_date = datetime.strptime(self.date_of_joining, "%d-%m-%Y")
    today = datetime.today()
    r = relativedelta.relativedelta(today, join_date)
    self.numbers_of_months_worked = r.years *12 + r.months

  #This function takes argument in form of string and returns a boolean value if the string matches the DD-MM-YYYY format or not
  def check_date_format(self,date):
    # initializing format
    format = "%d-%m-%Y"
    # checking if format matches the date
    res = True
    # using try-except to check for truth value
    try:
      res = bool(datetime.strptime(date, format))
    except ValueError:
	    res = False    
    return res

  #Calculates age to check for eligibility in constructor and exits if age isn't in range
  def calculate_age(self, test_str):
    birthDate = datetime.strptime(test_str, "%d-%m-%Y")
    days_in_year = 365.2425
    age = int((datetime.today() - birthDate).days / days_in_year)
    self.age = age

  #Displays important employe details
  def display_employee_details(self):
    print("The details of the Employee:")
    print("Name: ",self.name)
    print("Gender: ", self.gender)
    print("Date of Birth: ", self.date_of_birth)
    print("Age: ", self.age)
    print("Date of joining: ", self.date_of_joining)
    print("Hobbies", self.hobbies)

  #Updates employee details of the parameters passed by user
  def update_employee_details(self, name = None, gender = None, date_of_birth = None):
    if name:
      self.name = name
    if gender:
      self.gender = gender
    if date_of_birth:
      while self.check_date_format(date_of_birth) != True:
        date_of_birth = input("Input Date of Birth in DD-MM-YYYY format please!")
      self.date_of_birth = date_of_birth

    print("Employee details have been updated!")

  #Promotes employee by given increment or level entered or 10% and 1 respectively with simple arithmetic operations
  def promote_employee(self, increment = 10, level = 1):
    self.salary += self.salary*(increment/100)
    self.level += level

  #Demotes employee by given decrement or level entered or 10% and 1 respectively with simple arithmetic operations
  #Takes care to not to let any value go negative
  def demote_employee(self, decrement = 10, level = 1):
    if self.salary > 0 and (self.level-level)>0:
      self.salary -= self.salary*(decrement/100)
      self.level -= level
    else:
      print("Cannot demote employee any further.")

  #saves the object to the dataframe and converts the dataframe to csv
  def save_employee_details(self):
    df.loc[len(df.index)] = [self.name, self.gender, self.date_of_birth, self.numbers_of_months_worked, self.salary, self.level, self.hobbies]  
    print(df)
    df.to_csv('employees.csv')

  def add_hobbies(self, stringOrList):
    if type(stringOrList) == str:
      self.hobbies.append(stringOrList)
    else:
      self.hobbies += stringOrList
    print("New List of hobbies: ", self.hobbies)

  def remove_hobbies(self, stringOrList):
    if type(stringOrList) == str:
      self.hobbies.remove(stringOrList)
    else:
      for i in stringOrList:
        self.hobbies.remove(i)
    print("Updated List of Hobbies: ", self.hobbies)

  def get_experience(self):
    years = self.numbers_of_months_worked // 12
    months = self.numbers_of_months_worked % 12
    print(f'{years} years and {months} months')

  def total_number_of_employees(self):
    print(f"Total number of Employees are: {len(df.index)}")

  def get_experience_by_name(self, name):
    i = df[df['Name']==name]
    print(f"Work experience of {name} is {i['Number_of_Months']}")
    
if __name__=="__main__":
  names = []
  genders = []
  dates_of_birth = []
  numbers_of_months_worked = []
  salaries = []
  levels = []
  hobbies = []

  dff = {'Name': names,'Gender': genders,'Date_of_Birth': dates_of_birth ,'Number_of_Months': numbers_of_months_worked, 'Salary': salaries, 'Level': levels,'Hobbies': hobbies}
  df = pd.DataFrame(dff)

employee1 = Employee('a', 'M', '10-10-2020', '10-10-2020', ['H1', 'H2'])

#This won't work as the object was not created
employee1.date_of_joining

em = Employee('a', 'M', '10-10-1990', '10-10-2020', ['H1', 'H2'])

em.display_employee_details()

em.add_hobbies("H3")

em.add_hobbies(["H4", "H5"])

em.remove_hobbies("H5")

em.remove_hobbies(["H3", "H4"])

em.get_experience()


em.save_employee_details()

em.total_number_of_employees()

pavan = Employee('Pavan', 'M', '16-01-1990', '23-01-2023', ['Travelling', 'Coding'])

pavan.save_employee_details()

pavan.total_number_of_employees()

pavan.get_experience_by_name('pavan')